# read

* 05-a-2000  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сменете вашия prompt с нещо по желание. После върнете оригиналния обратно.
* 05-a-2100  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Редактирайте вашия .bash_profile файл, за да ви поздравява (или да изпълнява някаква команда по ваш избор) всеки път, когато влезете в системата.
* 05-a-2200  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Направете си ваш псевдоним (alias) на полезна команда.
* 05-b-2000  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ".
* 05-b-2800  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.
* 05-b-3100  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.
* 05-b-3200  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния изход подходящо съобщение за броя на всички файлове и всички директории в нея.
* 05-b-3300  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.
* 05-b-3400  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NB! Символният низ може да съдържа интервал (' ') в себе си.
* 05-b-4200  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане).
Примерен .c файл:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#include <stdio.h>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int main(int argc, char *argv[]) {  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (argc == 1) {  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		printf("There is only 1 argument");  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	} else {  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		printf("There are more than 1 arguments");  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	return 0;  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тук влагането е 2, понеже имаме main блок, а вътре в него if блок.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Примерно извикване на скрипта:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./count_nesting sum_c_code.c

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Изход:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The deepest nesting is 2 levels
* 05-b-4300  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Напишете shell script, който по подаден като аргумент файл с map между <nickname> -> <реален username> и nickname, ще ви улесни да изпращате съобщения на хората.  
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пример за файл указател:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tinko s61966  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minko s881234  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ginko s62000  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dinko s77777

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Примерно извикване на програмата:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./send_message myAddressBook dinko

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И вече може да изпращате съобщения на човека с username s77777

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NB! Можете да създавате нови потребители използвайки 'sudo useradd username'. За да проверите дали се пращат съобщенията отворете 2 сесии към виртуалката ви, създайте новият потребител, логнете се с него ( 'sudo su username' от едната сесия ) и от другата сесия пратете съобщението.
* 05-b-4301  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи: име на файла указател, пълно име на човека (това, което очакваме да е в /etc/passwd) и избран за него nickname.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Файлът указател нека да е във формат:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nickname, който лесно да запомните> <username в os-server>  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// може да сложите и друг delimiter вместо интервал

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Примерно извикване:  
./pupulate_address_book myAddressBook "Ben Dover" uncleBen

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Добавя към myAddressBook entry-то:  
uncleBen <username на Ben Dover в os-server>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***Бонус: Ако има няколко съвпадения за въведеното име (напр. има 10 човека Ivan Petrov в /etc/passwd), всички те да се показват на потребителя, заедно с пореден номер >=1,
след което той да може да въведе някой от номерата (или 0 ако не си хареса никого), и само избраният да бъде добавен към указателя.
* 05-b-4400  
Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и опционално експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.
* 05-b-4500  
Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение.

NB! Можете да тествате по същият начин като в 05-b-4300.txt
* 05-b-4600  
Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал.
Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала.
Скриптът да връща exit status:
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

Примери:
$ ./validint.sh -42 0 102; echo $?
1

$ ./validint.sh 88 94 280; echo $?
1

$ ./validint.sh 32 42 0; echo $?
2

$ ./validint.sh asdf - 280; echo $?
3
* 05-b-4700  
Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал.
Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала.
Скриптът да връща exit status:
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

Примери:
$ ./validint.sh -42 0 102; echo $?
1

$ ./validint.sh 88 94 280; echo $?
1

$ ./validint.sh 32 42 0; echo $?
2

$ ./validint.sh asdf - 280; echo $?
3
* 05-b-4800  
Да се напише shell скрипт, който приема файл и директория. Скриптът проверява в подадената директория и нейните под-директории дали съществува копие на подадения файл и отпечатва имената на намерените копия, ако съществуват такива.

NB! Под 'копие' разбираме файл със същото съдържание.
* 05-b-5500  
Да се напише shell script, който генерира HTML таблица съдържаща описание на потребителите във виртуалката ви. Таблицата трябва да има:
- заглавен ред с имената нa колоните
- колони за username, group, login shell, GECKO field (man 5 passwd)

Пример:
$ ./passwd-to-html.sh > table.html
$ cat table.html
<table>
  <tr>
    <th>Username</th>
    <th>group</th>
    <th>login shell</th>
    <th>GECKO</th>
  </tr>
  <tr>
    <td>root</td>
    <td>root</td>
    <td>/bin/bash</td>
    <td>GECKO here</td>
  </tr>
  <tr>
    <td>ubuntu</td>
    <td>ubuntu</td>
    <td>/bin/dash</td>
    <td>GECKO 2</td>
  </tr>
</table>
* 05-b-6600  

* 05-b-6800  

* 05-b-7000  

* 05-b-7100  

* 05-b-7200  

* 05-b-7500  

* 05-b-7550  

* 05-b-7700  

* 05-b-7800  

* 05-b-8000  

* 05-b-9100  

* 05-b-9200  

* 05-b-9500  

* 05-b-9501  

* 05-b-9600  

* 05-b-9601  
